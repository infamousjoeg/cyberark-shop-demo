---
- name: Setup Configuration for Service Mesh
  hosts: localhost
  connection: local
  gather_facts: yes  # Gather facts to detect OS
  vars_files:
    - vars/vars.yml
  tasks:
    # OS-specific Helm installation
    - name: Ensure Helm is installed (Ubuntu)
      become: true
      block:
        # First download the Helm signing key
        - name: Download Helm signing key
          get_url:
            url: https://baltocdn.com/helm/signing.asc
            dest: /tmp/helm-signing.asc
            mode: '0644'
          register: helm_key_download

        # Add the key to the apt keyring
        - name: Add Helm apt key
          ansible.builtin.shell: |
            cat /tmp/helm-signing.asc | gpg --dearmor > /usr/share/keyrings/helm.gpg
          args:
            creates: /usr/share/keyrings/helm.gpg
          when: helm_key_download is success

        # Add the repository with signed-by option
        - name: Add Helm repository with proper key
          ansible.builtin.apt_repository:
            repo: "deb [arch=amd64 signed-by=/usr/share/keyrings/helm.gpg] https://baltocdn.com/helm/stable/debian/ all main"
            state: present
            filename: helm-stable

        # Install Helm package
        - name: Install Helm
          apt:
            name: helm
            state: present
            update_cache: yes
      when: ansible_os_family == 'Debian'

    - name: Ensure Helm is installed (MacOS)
      community.general.homebrew:
        name: helm
        state: present
      when: ansible_os_family == 'Darwin'

    # Configure Kubernetes namespaces for service mesh
    - name: Apply Istio System Namespace
      kubernetes.core.k8s:
        state: present
        namespace: "istio-system"
        src: "files/namespaces/istio-system.yaml"

    - name: Apply Mesh Applications Namespace
      kubernetes.core.k8s:
        state: present
        namespace: "mesh-apps"
        src: "files/namespaces/mesh-apps.yaml"

    # First, determine actual Docker config path (expanding home directory)
    - name: Set Docker config path
      set_fact:
        docker_config_path: "{{ ansible_env.HOME }}/.docker/config.json"

    # Check if the config file exists before attempting to use it
    - name: Check if Docker config exists
      stat:
        path: "{{ docker_config_path }}"
      register: docker_config_file

    # Add debug information to help troubleshoot
    - name: Debug Docker config information
      debug:
        msg: "Docker config path: {{ docker_config_path }}, Exists: {{ docker_config_file.stat.exists | default(false) }}"

    # Create an empty Docker config if it doesn't exist
    - name: Create Docker config directory
      file:
        path: "{{ ansible_env.HOME }}/.docker"
        state: directory
        mode: '0755'
      when: not docker_config_file.stat.exists

    # Create a minimal Docker config if needed
    - name: Create minimal Docker config if not exists
      copy:
        dest: "{{ docker_config_path }}"
        content: '{"auths":{}}'
        mode: '0644'
      when: not docker_config_file.stat.exists
      register: docker_config_created

    # Read Docker config with command if it exists
    - name: Read Docker config with command
      command: "cat {{ docker_config_path }}"
      register: docker_config_content
      changed_when: false
      when: docker_config_file.stat.exists
      # Ignore errors in case cat fails but file exists
      ignore_errors: yes
      no_log: false  # For debugging, normally set to true for security

    # Create Docker Hub image pull secret with appropriate config
    - name: Create Docker Hub image pull secret from local config.json
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: dockerhub-creds
            namespace: mesh-apps  # Explicitly define namespace instead of variable
          type: kubernetes.io/dockerconfigjson
          data:
            .dockerconfigjson: "{{ (docker_config_content.stdout | b64encode) if (docker_config_content is defined and docker_config_content.rc == 0) else '{\"auths\":{}}' | b64encode }}"
    # Setup trust anchor for certificate validation
    - name: Create Venafi Trust Anchor Secret
      kubernetes.core.k8s:
        state: present
        namespace: cyberark
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: venafi-trust-anchor
            namespace: cyberark
          type: Opaque
          data:
            root-cert.pem: "{{ lookup('file', '{{ trust_anchor_root_ca_pem }}') | b64encode }}"

    # Configure Istio CSR integration
    - name: Generate Istio CSR Configuration
      ansible.builtin.copy:
        src: "files/templates/helm/istio-csr-values.yaml.j2"
        dest: "files/artifacts/venafi-install/istio-csr-values.yaml"
        mode: '0644'

    # Apply Firefly Mesh Issuer for managing certificates
    - name: Apply Firefly Mesh Issuer
      kubernetes.core.k8s:
        state: present
        namespace: "istio-system"
        src: "files/templates/servicemesh/firefly-mesh-wi-issuer.yaml"

    # Create ConfigMap for Istio CSR
    - name: Create Istio CSR CA ConfigMap
      kubernetes.core.k8s:
        state: present
        namespace: cyberark
        definition:
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: istio-csr-ca
            namespace: cyberark
          data:
            issuer-name: firefly-mesh-wi-issuer
            issuer-kind: Issuer
            issuer-group: firefly.venafi.com

    # Configure trust anchor for Firefly
    - name: Create Firefly Trust Anchor
      ansible.builtin.template:
        src: "files/templates/servicemesh/firefly-trust-anchor.yaml.j2"
        dest: "files/artifacts/venafi-install/firefly-trust-anchor.yaml"
        mode: '0644'

    - name: Apply Firefly Trust Anchor
      kubernetes.core.k8s:
        state: present
        namespace: "istio-system"
        src: "files/artifacts/venafi-install/firefly-trust-anchor.yaml"

    # Generate and apply Venafi Helm manifests for Istio CSR
    - name: Generate Venafi Helm manifests for Istio CSR
      ansible.builtin.command:
        cmd: |
          venctl components kubernetes manifest generate
          --namespace cyberark
          --istio-csr
          --istio-csr-version "{{ cert_manager_istio_csr_version }}"
          --istio-csr-values-files istio-csr-values.yaml
          --image-pull-secret-names venafi-image-pull-secret
      register: venafi_manifest_output
      changed_when: venafi_manifest_output.rc == 0

    - name: Save Venafi Helm manifest output to file
      ansible.builtin.copy:
        content: "{{ venafi_manifest_output.stdout }}"
        dest: "files/artifacts/venafi-install/venafi-manifests-istio.yaml"
        mode: '0644'
    
    # Apply Venafi manifests for Istio
    - name: Sync Venafi Istio manifests using venctl
      ansible.builtin.command:
        cmd: |
          venctl components kubernetes manifest tool sync --file files/artifacts/venafi-install/venafi-manifests-istio.yaml
      environment:
        ISTIO_TRUST_DOMAIN: "cluster.local"
      register: venctl_sync_output
      changed_when: venctl_sync_output.rc == 0 

    # Generate Istio configuration
    - name: Install Istio Configuration
      ansible.builtin.template:
        src: "files/templates/servicemesh/istio-config.yaml.j2"
        dest: "files/artifacts/venafi-install/istio-config.yaml"
        mode: '0644'
